#一.进程

##1.引入

早期的计算机只能执行一个任务，由监控器监控到前一个任务完成后，才会去执行下一个任务。但是随着计算机程序种类、外部设备种类越来越多，这种单任务的执行方式显然就绷不住了。

我们提出**分时(time-sharing)**的概念（也就是时间片切分复用）

![](图片\6.1.PNG)

此时我们就需要对研究的对象“任务”进行抽象——**进程**。

##2.进程的状态

为了更好的管理进程，OS首先定义了进程的生命状态：

<img src="图片\6.3.PNG" style="zoom:80%;" />

1. **新生状态（new）**：进程刚**被内核创建**，还未完成初始化，不能被调度执行。在**内核对进程所需要的数据结构完成初始化**后，进程迁移至就绪状态。
2. **就绪状态（ready）**：进程可以执行，但还没有被调度器选择（因为CPU资源有限，不可能同时运行，由OS决定调度器决定某一时刻哪些进程被调度到CPU上执行）。
3. **运行状态（running）**：进程正在处理器上运行。当一个进程执行一段时间后，调度器可以选择**中断**它的执行并重新将其放回调度队列（用户态 $\rightarrow $ 内核态），其迁移至**就绪状态**；当进程结束，它就会迁移至**终止状态**；如果一个进程需要等待某些外部事件，它可以放弃CPU并迁移至**阻塞状态**。
4. **阻塞状态（blocked）**：表示该进程需要等待某外部事件，短时间不再运行.
5. **终止状态（terminated）**：进程完成了执行，内核回收进程相关资源。

> 阻塞状态中所谓的外部事件就是进程需要某些外部信息，此时OS会把进程调走，防止其占用CPU的资源，进入阻塞状态直至外部事件完成；中断程序(也可以被调度)只会把进程转换到就绪状态，而不会阻塞。
>
> 两者的主要区别在于，阻塞状态必须要等待外部时间完成，是无法被调度运行的状态，而中断后会调回至就绪状态，可以随时再被调度。
>
> ==中断进一步理解？==

**Linux进程状态：**

![](图片\6.4.PNG)

##3.进程的内存结构

**每个进程都有独立的虚拟内存空间**，所以会有进程独占全部内存的假象（而且这种直接利用虚拟内存的抽象减轻了编程的压力）。

首先进程的虚拟内存空间布局可大致分为：

* 静态部分：程序运行所需要的代码和数据。
* 动态部分：程序运行期间的状态（程序计数器、堆、栈...）

<img src="图片\6.2.jpg" style="zoom:70%;" />

* **用户栈**：保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量等各种所需要的临时数据。

* **用户堆**：管理动态分配的临时变量

* **内存映射区域**：进程的执行有时需要依赖**共享的代码**库（如libc库），其被标记为**只读**。

* **数据与代码段**：原本保存在进程需要执行的二进制文件中，在进程执行前被加载到虚拟内存空间。**数据段主要保存全局变量的值，代码段主要保存进程所需的代码。**

* **内核部分**：每个进程的虚拟地址空间里都映射了**相同的内存内核**，当进程处于用户态时，这段内存对其不可见，当进程处于内核态时，才能访问内核内存。
  
  * 内核态运行时需要的代码和保存临时数据空间。
  * 当进程由于中断或系统调用(软中断)进入内核后，会使用内核栈。
  
  > 内核内存和用户态内存在虚拟空间可能是连续的，但是在物理空间上其由两个页表（对应两个页表基地址寄存器）分别进行管理（AArch64体系下）。
  
* PS：进程还会映射一些匿名的内存区域用于完成缓存、共享内存等工作。

##4.进程相关的数据结构PCB

为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为**进程控制块（PCB Process Control Block）**，它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是**进程管理和控制的最重要的数据结构**，每一个进程均有一个PCB，在创建进程时建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。

进程管理和控制信息：进程标识符PID（Process IDentifier）、进程状态、虚拟内存状态、打开的文件...

```c
struct task_struct {
	unsigned int __state; //进程状态
	void *stack;
	struct list_head tasks;
    
	struct mm_struct *mm; //虚拟内存状态
	struct mm_struct *active_mm;
	pid_t pid; //进程标识符
	pid_t tgid;
    
    //进程间关系
	struct task_struct __rcu *real_parent; //Real parent process
	/* Recipient of SIGCHLD, wait4() reports: */
	struct task_struct __rcu *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
    
	u64 utime;
	u64 stime;
    
	struct fs_struct *fs; //文件系统信息
	struct files_struct *files; //已打开文件的fd表
    
	/* CPU-specific state of this task: */
	struct thread_struct thread;
};
```

##5.不同进程间的上下文切换

由于进程对于CPU资源的利用是以时间切片的方式进行的，所以在一个时间周期内一定存在不同进程间的相互切换，我们称之为**上下文切换**。

* 什么时候进行上下文切换？

  某一进程通过**异常**、**中断**或者**系统调用**进入内核（也即由运行状态迁移为就绪状态），**其上下文（进程运行时的寄存器状态）就需要保存到对应的PCB中**。

* 原有进程的状态如何保存与恢复？

  上下文保存在对应的PCB中，被调度时，从PCB中取出上下文并回复即可。

![](图片\6.5.PNG)

##6.进程相关的基本操作

###（1）进程创建：fork (Linux)

####①语义

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);//定义
```

语义：为调用进程创建一个几乎一模一样的新进程。

* 调用进程为父进程，新进程为子进程
* 接口简单，无需任何参数

####②行为与特性

虽然“一模一样”，但fork后的父子本质上是克隆关系，**两个进程均为独立的：**

* 拥有不同的PID

* 可以并行执行，互不干扰（除非使用特定的接口）

* 父进程和子进程会共享部分数据结构（内存、文件等）（写时拷贝机制）

![](图片\6.6.PNG)

> 运行结果可能是父进程先打印，子进程后打印。
>
> 这是因为两个进程是独立的，其可以同时运行，执行顺序完全取决于调度器。

```c
// 有趣的小例子。
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
char str[11] = {0};
int main(int argc, char* argv[]) {
	int fd = open("test.txt", O_RDWR);
	if (fork() == 0) {
	ssize_t cnt = read(fd, str, 10);
	printf("Child process: %s\n", str);
	} 
    else {
		ssize_t cnt = read(fd, str, 10);
		printf("Parent process: %s\n", str);
	}
	close(fd);
	return 0; 
}
/*最终的结果是什么？
Parent process: abcdefghij
Child process: klmnopqrst

——不是说好一模一样的嘛...
原因在于fork()创建的父子进程之间有部分的数据是在共享内存区的，换言之是完全一模一样的。而每个进程在运行过程中都会运行一个已打开文件的文件描述符表，在创建新进程的时候，父子实际上共用同一个fd表的引用。加之Linux操作系统在实现read操作的时候会对文件抽象进行加锁（互斥访问），因此父子进程不可能读到完全一样的字符串。

PS：所谓的文件描述符(File Descriptor,fd)是指OS提供的对于某一文件引用的抽象，之所以使用统一的文件标识符fd类型而不直接使用指向文件的指针，是因为文件结构可能根据不同的文件系统变化，提供单一的抽象有利于使用和OS管理。
```

> 写时拷贝(Copy-On-Write)在fork中的应用
>
> 早期的fork实现：将父进程**直接拷贝**一份
>
> * 时间性能差：耗时随父进程占用内存的增加而增加。
> * 空间效率低：一部分虚拟内存（共享代码库、代码段）是只读的，对他们进行拷贝没有必要。
> * 无用功：由于进程有时会在调用fork之后立即调用exec以载入新的可执行文件，同时重置相关地址空间，所以说这一步拷贝直接就被覆盖了，完全没有用处。
>
> 故而我们可以使用写时拷贝的思想，只拷贝内存映射，不拷贝实际内存。

#### ③优缺点分析(对比CreateProcess)

优点:

* **接口简洁，实现机制简单（CoW只需拷贝内存映射）**
* 将进程“创建”和“执行”（exec）解耦，提高了**灵活度**
* 强调**进程之间的内在关系**（进程树、进程组），为进程的管理提供了便利。

缺点:

* **实现与代码维护愈发复杂：**随着操作系统功能越来越多，fork实现过程中要考虑的特殊情况越来越多，越发复杂；而且由于fork的实现与进程、内存管理等模块的耦合度越来越高，所以内核对其进行代码维护的难度也越来越大。

* **性能差、可扩展性差**（不如vfork和spawn） 
* **存在安全漏洞**：父子进程之间的共享状态可能成为攻击者的重要切入点，如BROP攻击。
* **完全拷贝**过于粗暴（不如clone选择性拷贝） 
* **不可组合性** (例如：fork() + pthread())

**对比Windows的CreateProcess：**

CreateProcess从头开始创建进程，没有fork那种偷懒的共享内存，故而需要对进程运行的参数进行大量配置。在提供灵活性、逻辑上更加直观的同时增加了接口的复杂度。并且其创建的进程之间的联系更弱。

> fork比较适合应用于进程之间存在较强联系的场景，比如shell中创建的进程虽然功能不相同，但是属于同一个用户，所以可以共享很多状态；Web服务场景中，各用户的请求对应的程序的处理逻辑较为相似，所以也比较适合用fork。
>
> CreateProcess创建的**进程联系较弱，功能更多元，可操作性更强**。对比fork与内存管理等模块耦合度较高，父子之间的进程有较强的联系，代码逻辑较为复杂，不利于内核进行代码维护。所以CreateProcess更适合需要OS介入管理的场景，比如要求父进程创建一个子进程，并希望设置共享内存来进行进程间的通信。用CreateProcess更方便内核进行管理。

#### ④替代方案

#####A.posix_spawn

相当于**fork + exec的结合**，需要填写一堆参数。**可扩展性和性能**有了一定的提高，但是由于fork可以在exec之前增加对新进程的一系列设定，而spawn只有两个给定的定制参数，故而其**不如fork灵活**。

#####B.vfork

类似于fork，但让**父子进程共享同一地址空间**。这和写时拷贝还不同，写时拷贝是有子进程空间，只不过其各自的虚拟内存空间“恰巧”都映射到了同一片物理内存空间上而已。

* 优点：**连映射都不需要拷贝，性能更好**。

* 缺点：
  * 比较适合进程在创建后立即exec的场景中：因为任意一个进程对内存空间的修改都会影响到其它进程，所以一般使用vfork的场景都是，创建完子进程之后父进程立即阻塞，直到子进程调用exec或者退出为止。
  
    ==为啥子进程调用exec之后父进程就可以停止阻塞？==
  
  * 共享地址空间存在安全问题

#####C.clone

fork的“进阶版”，**可以选择性地不拷贝内存**。其高度可控，可依照需求调整，应用范围更广（如之后的创建线程）。但是接口比fork复杂，选择性拷贝容易出错。

###（2）进程执行：exec

上面的fork创建子进程虽然简单，但是很无脑，因为很多时候用户需要子进程执行与父进程完全不同的任务。这就需要exec接口簇，其中execve是功能最全面的。

```c
#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);
//pathname参数是进程需要载入的可执行文件的路径
//argv是进程执行所需要的参数
//envp是为进程定义的环境变量，一般以键值对字符串的形式传入
```

当execv被调用的时候，OS至少需要完成以下几个步骤：

* 根据pathname所指明的路径，**将可执行文件的数据段与代码段加载到当前进程的虚拟内存空间中**。

* 利用地址空间随机化（Address Space Layout Randomization, ASLR）改变用户堆和用户栈的起始地址，**重新初始化堆和栈**，增强进程的安全性。

  ==改变的是虚拟地址还是物理地址？==

* 将PC寄存器设置到可执行文件代码段定义的入口点，该入口点会最终调用main函数。

###（3）进程间同步：wait

在Linux系统中，父进程可以通过wait操作来对子进程进行监控。主要介绍waitpid

```c
pid_t waitpid(pid_t pid, int *wstatus, int options);
//pid表示子进程的id
//第二个参数用来保存子进程的状态
//第三个参数用来包含一些选项
```

waitpid会阻塞等待，直到子进程退出。如果子进程退出，waitpid会立即返回并且设置**status变量**的值，父进程可以访问status变量来获取子进程的状态。

PS：父进程可以利用WIFEXITED函数来确定子进程是否退出。

```c
int main(int argc, char* argv[]) {
	int rc = fork();
	if(rc < 0) {// fork 失败
		fprintf(stderr, "Fork failed\n"); 
	} 
    else if (rc == 0) { //子进程
		printf("Child process: existing\n");
	} 
    else { //父进程
		int status = 0; 
		if(waitpid(rc, &status, 0) < 0) { //waitpid返回值小于0表示等待失败
			fprintf(stderr, "Parent process: waitpid failed\n"); 
        	exit(-1);
		}
		if(WIFEXITED(status)) { //WIFEXITED函数返回值为0表示子进程已经退出
			printf("Parent process: my child has exited\n");
		} 
        else {
			fprintf(stderr, "Parent processes: waitpid returns for unknown reasons\n");
		} 
    } 
}
```

在Linux中，wait操作不仅可以起到**监控子进程**的作用，还能够**回收已经运行结束的子进程和释放资源**。

如果父进程没有调用或者还没有来得及调用wait操作，即使子进程已经终止，其所占有的status和PID也不会被释放（方便可能的后续监控），这种进程就是**僵尸进程**。大量僵尸进程会挤占系统的运行资源。

父进程退出的时候，由其创建的所有僵尸子进程会被内核的第一个进程init通过wait的方式回收。

##7.进程树与进程组

一个系统中可能有许多进程，那么我们如何去管理各种进程之间的关系呢？通过观察PCB我们也能发现，进程之间的关系实际上是一种树状的关系（PCB中维护了各种父子指针），也就是所谓的**进程树**。其产生的根源在于fork创建进程的父子方式。

而且多个进程可以属于同一个**进程组**，我们可以在shell程序中向同一个进程组中的所有进程发送信号。父进程和子进程默认属于同一个进程组。

#二.线程

##1.引入

早期计算机中，进程一般是操作系统用来管理程序、进行调度的最小单位，但是随着硬件技术的发展，进程这一抽象开始显得愈发笨重：

* **创建进程的开销大**：需要创建独立的虚拟地址空间，载入各种代码段数据段、初始化堆栈...
* **进程间数据交流麻烦**：由于进程的虚拟地址空间独立，所以其之间的数据共享与同步比较麻烦，一般只能基于**共享虚拟内存页（粒度较粗）或进程间通信（开销较大）**。这就导致程序之间很难以进程为抽象单位进行并行操作。

**线程就是进程内部可独立执行的单元**。其共享同一个虚拟内存空间，方便并行操作时进行数据通信；同时其各自又保留自身的运行时所需的状态（**上下文**），保证其可以独立并行。

之后其取代进程，成为OS调度和管理程序的最小单位（所以实际上上下文切换的单位是线程）。

## 2.多线程的地址空间布局

由于线程本质上是进程的一部分，故而**其生命状态和进程类似**，受OS管理。

<img src="图片\6.3.jpg" style="zoom:80%;" />

多线程的地址空间主要有两个特征：

* “**分离”的内核栈和用户栈**：栈是运行时用来存放临时数据的地方，由于各线程的运行相对独立，所以**进程为每个线程准备了不同的栈**。

  > 自然，为了满足各线程在内核态下的运行要求，进程存储空间下的内核部分也要为各个线程准备对应的内核栈。

* **共享的其它区域：**进程除栈以外的区域由各线程共享，包括数据段、代码段、堆。

  > 关于进程中的共享堆：线程需要动态分配更多内存时使用。由于是共享区域，故而其实现需要同步原语。

## 3.线程的分类与联系模型

根据线程是由用户态应用还是内核创建与管理，可将线程分为两类：

* 用户态线程（纤程）：用户自己创建，内核不可见，不受系统调度器管理。线程的相关信息主要存放在应用数据中。
* 内核态线程：内核创建，受内核管理，线程的相关信息存储在内核中。

> 内核态线程表征的更多是一种管理模式，表示其由操作系统所进行调度的线程；用户态线程由应用程序自身进行管理。前者拥有进入内核态的能力，后者只能与前者进行协作。

用户态线程更加轻量级、创建开销更小，但功能也更为受限，故而其进行内核态相关操作需要内核态线程进行协助。

为了实现用户态线程与内核态线程的协作，OS会建立两类线程之间的关系，称为多线程模型：

<img src="图片\6.4.jpg" style="zoom:80%;" />

* 多对一模型：多个用户态线程对应一个内核线。每次只能有一个用户态线程进入内核，其它需要内核服务的用户态线程会被阻塞。

  * 优点：内核管理简单
  * 缺点：可扩展性差。

  > 在主流操作系统中被弃用，用于各种用户态线程库中

* 一对一模型：每个用户态线程映射单独的内核态线程。

  * 优点：解决了多对一模型中的可扩展性问题
  * 缺点：内核线程数量大，开销大

  > 主流操作系统都采用一对一模型。

* 多对多模型：一般内核态线程的数量要比用户态线程数量多。

  * 优点：处于一对一与一对多的中间状态，减轻了多对一模型的阻塞问题，同时降低了一对一模型的性能屏障。
  * 缺点：不过其使内核态线程的管理变得复杂。

  > 在虚拟化中得到广泛应用。

## 4.线程控制块与线程本地存储

###（1）线程控制块TCB

与进程类似，线程也有自己的**线程控制块**（Thread Control Block，TCB），**用来存储与自身相关的信息**。

在一对一线程模型中，内核态线程与用户态线程会分别保存自己的TCB：

* 内核态的TCB：与PCB相似，会存储线程的运行状态、内存映射、标识符等信息。

  > Linux中进程与线程使用的是同一种数据结构（task_struct），其在内核态线程陷入内核过程中进行上下文切换时会使用。

* 用户态的TCB：**由线程库定义**。可以认为是内核态TCB的扩展，用来存储更多和用户态自身相关的信息，其中有一个重要的功能就是线程本地存储TLS。

  > Linux：pthread结构体；Windows：TIB（Thread Information Block）

###（2）线程本地存储TLS

由于线程不具有独立的地址空间，其之间共享代码段，所以**不同的线程可能会执行相同的代码**。所以说有可能会产生代码段中的“全局变量”共用的现象，如果此全局变量的语义是特异化的，就会产生**正确性问题**。比如表征某个线程系统调用错误的变量errno。

TLS就是一种实现线程独有“全局变量”（变量名可能一样）的机制，相当于对原有全局变量在用户态线程的TCB上增加了一个本地拷贝，使得各个线程对其操作不会影响其它线程。

<img src="图片\6.5.jpg" style="zoom:80%;" />

**实现：**

线程库为所有的线程都创建一个完全相同的TLS，保存在内存的不同地址上。当一个线程被调度时，pthread线程库会找到该线程TLS的起始地址，并且载入到**段寄存器FS(x86)/TPIDR_EL0(AArch64)**中。由于TLS结构的一致性，某个变量在不同TLS上对应的地址偏移量是相同的，所以各线程都可以用类似访问“全局变量”的方式访问它。

## 5.线程的基本操作

POSIX线程库一般称为pthreads，包含一套通用的接口，不同OS可根据现实需求对其进行实现。

###（1）创建：pthread_create

**利用clone创建于型属于原进程（地址空间设为一致）、与原进程大量共享数据结构、拥有私有栈的实例**，这个实例可以说是一个特殊化的进程，也是我们通常意义上的线程。

内核态：创建相应的内核线程以及内核栈。

用户态：创建TCB、应用栈和TLS

###（2）退出：pthread_exit

一般一个线程的主函数执行结束之后，其就会被隐式地调用。显式使用的目的一般是为了**设置返回值**（会被pthread_join获取）。

###（3）暂停：pthread_yield

立即暂停执行，出让CPU资源给其它线程，可以帮助调度器做出更优的决策。

### （4）合并：pthread_join

主要是针对线程之间可能会存在的相互依赖的线程。合并操作允许一个线程等待另一个线程的执行。并获取其执行结果。

## 6.线程上下文切换

由于CPU的有限性，计算机内部线程的都是以一种分时的方式来进行的，其就必然会涉及到线程间控制流的切换，这就是所谓的**上下文切换机制**。

###（1）线程的上下文与TCB

 线程的上下文即重要的寄存器信息：

* **程序计数器PC**：elr_el1

  表征当前程序所进行到的位置。

* **常规通用寄存器**：x0-x30

  表示当前CPU正在处理的一些数据。

* **特殊寄存器：**

  用来存储CPU当前的状态以及一些硬件配置。

  * 页表地址：TTBR0_EL1

  * 栈指针：sp_el0
  * CPU状态（如条件码）：spsr_el1

TCB结构：

<img src="图片\6.6.jpg" style="zoom:80%;" />

由于一对一模型中用户态线程都已一个代理内核态线程，所以其上下文是存储在内核态线程的TCB当中的。内核栈紧接TCB之下，供线程进入内核之后使用。

###（2）上下文切换的实现

由于线程的上下文切换涉及到一些比如使用一些内核数据结构以寻找到目标线程、页表切换、特殊寄存器的保存与恢复等**特权级较高的操作**，所以上下文切换的核心操作都是在内核态进行的。

#### ①进入内核态、保存上下文

应用线程通过**异常、中断或系统调用**进入内核态。硬件自动完成以下操作：

* **运行状态将切换到内核态**（EL1）
* 开始使用sp_el1作为栈指针（**用户栈切换到内核栈**）
* **保存上下文**：PC、应用线程的CPU状态等

#### ②切换页表和内核栈

进入到内核态之后，OS首先会利用相关内核态数据结构，**确定下一个被调度的线程**，之后就要进行控制流的转移：

* **切换页表：**将页表相关寄存器的值置为目标线程的页表基地址。

* **切换内核栈：**首先找到目标内核栈的栈顶指针（目标线程的TCB） ，然后修改sp_el1的值至目标内核栈。

  > 切换内核栈可以认为是线程执行的分界点（切换之后变为目标线程执行）

#### ③上下文恢复，返回用户态

根据内核栈与保存TCB之间的地址关系，将上下文信息TCB取出，恢复到寄存器中。

之后调用AArch64中的eret指令，由硬件执行相关操作返回应用态继续执行即可。

<img src="图片\6.7.jpg" style="zoom:80%;" />

共涉及到两次权限等级的转换以及三次栈切换。

