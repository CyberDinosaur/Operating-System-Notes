# 一.概述

##1.为什么进程间需要通信？

###（1）独立进程

独立进程：一个进程就是一个应用，虚拟内存之间相互隔离。其不会去影响其他进程的执行，也不会被其他进程影响。

###（2）协作进程

而为了应用的更好执行，其之下的各个进程需要进行通信——协作进程：和独立进程相反，可以影响其他进程执行或者被影响。

好处：

* **模块化**: 为了提高**复用性**就必须要模块化，而模块化必然会要求进行进程间通信。
* **隔离性**：把应用的所有模块都放在一个进程里，虽然交互更加方便，但是隔离性较差，无法保障安全性。
* 提高应用的**容错能力**，和模块化类似。
* **加速计算:** 不同进程专注于特定的计算任务，性能更好。
* 信息共享: 直接共享已经计算好的数据，避免重复计算。

##2.IPC定义

两个(或多个)不同的进程，通过共享资源或内核进行通信，来传递控制信息或数据。

> 交互的双方：发送者/接收者、客户端/服务端、调用者/被调用者
>
> 通信的内容：一般叫做“消息”

<img src="图片\IPC01.jpg" style="zoom:80%;" />

# 二.共享内存通信

## 1.直接共享内存

直接在两个或者多个内存之间建立共享区域，在共享区域上建立数据结构。进程可以直接使用该共享区域上的数据，而不存在“消息”的抽象。

这种方式简单直观，但是会导致许多问题：

* 由于共享内存的虚拟地址在不同进程的地址空间中可能是不同的，这会导致指针以及与指针相关的数据无法使用。
* .与多进程的隔离性存在冲突：谁想用谁用。

## 2.基于共享内存的消息传递

###（1）共享内存

在不考虑IPC的时候，两个进程是被内核隔离开的，它们处在不同的地址空间内，其系统资源（如内存数据）都是互相隔离的。

在基于共享内存的消息传递这种IPC策略中，OS会为两个进程映射一段**共享内存**，也即在两个进程的虚拟地址空间中有一段是指向同一个物理内存的。

<img src="图片\IPC02.jpg" style="zoom:80%;" />

### （2）具体实现

其挑战在于：做好同步

* 发送者不能覆盖掉未读取的数据
* 接收者不能读取别的数据

所以我们采用**轮询**的方式，接受者会不停地轮询发送者消息的状态信息，一旦观测到状态信息为"准备就绪"，就表示发送者发送了一个消息。

此时发送者开始不断轮询接受者的状态信息；接受者读取发送者的消息，处理相关请求，并在接收消息上准备返回结果，准备完成就设置自身的状态信息为就绪。

###（3）问题与特点

不足：

1. **轮询导致资源浪费**，特别是在通信不频繁的场景下。
2. 固定一个检查时间，时延长。

特点与优点：

* OS在通信的过程中不干预数据传输，只是负责建立共享内存，不管后续的通信过程（有些时候我们不想OS来干扰我们——更多的自主性）。
* 从数据传递的性能上来看，共享内存可以实现**零内存拷贝**的数据传递。

# 三.OS辅助的消息传递

## 1.简介

操作系统辅助的内存传递就是指，内核为用户态提供相互通信的接口，可以让其实现简单的通信。

其自身就不需要管什么共享内存，也更不要实现什么低效的轮询制度，只需发送请求，所有的通信由OS统一进行管理。

> 简单留给用户，复杂留给OS。

和基于共享内存的消息传递的对比：

* **内存拷贝**：消息传递的过程中需要将数据从发送者的用户态内存拷贝到内核内存，之后再拷贝到接受者内存——**两次拷贝**：

  > 使用内存重映射技术可以实现一次拷贝。

* **简单**：OS将相关的功能进行抽象封装，并作为服务提供给用户：

  * 一方面使得用户的需求实现更加简洁；

  * 另一方面使得下层的实现与上层的需求进行解耦，可以更高效的实现更加复杂的功能，比如内核可以保证每一次通信接口的调用都代表一个消息被发送或者接收（或出现异常错误），并且能更好的支持变长的消息...这些功能如果放在共享内存策略中，只能由用户态软件自行封装实现。

* **高效利用计算资源&低时延**

* **安全性保证**：由内核控制消息传递可以使得进程间隔离性更强，更有安全性。

* **面向多方通信场景**：共享内存策略在实现多方通信的场景时是十分复杂且不安全的，OS辅助策略就可以很好的解决这些问题。

##2.基本内容

### （1）通信过程——控制流转移

OS辅助策略的消息传递机制除了考虑数据的传输，往往还会附带控制流转移的功能。

由于用户态进程实际上是运行在OS抽象出来的时间片上的，并且具有多种状态。IPC中的控制流转移，就是**通过内核对进程的运行状态和运行时间的控制来实现的**。

<img src="图片\IPC03.jpg" style="zoom:80%;" />

* 接收者进程初始化后进入阻塞式等待状态
* 发送者进程发起RPC通信请求。
* 内核将发送的消息传递给接收者，然后让发送者进入阻塞式等待状态，并将接收者唤醒到就绪状态。（控制流转移）
* 接收者在用户态进行相关处理，并发起通信请求。

> 所谓控制流转移的过程，实际上和线程上下文切换的过程十分类似。不过这里主要场景是消息的转移，控制流的转移只是附带的。

###（2）通信类型——同步和异步

<img src="图片\IPC04.jpg" style="zoom:80%;" />

####①概念异同

同步IPC中send操作会阻塞发送者进程直至该操作完成；而异步IPC中发送者/接收者不等待操作结果，直接返回。

同步的控制流会来回切换；异步是多个并行的控制流。

####②应用场景

* 同步IPC

  以双向通信为主，也有单向通信。

  双向通信用同步IPC很好理解，因为双向通信中**发送方需要等待接收方的结果**，所以同步通信就很自然。

  单向通信使用同步IPC主要是为了**发送者阻塞等待接受者接收**（发送的时候，接收者可能正在处理其他任务，无法及时给发送者接收确认的响应）。在同步IPC中，这一需求通过阻塞式等待实现。

  > 同步通信的方式更加直观、简洁，其有更好的编程抽象——函数调用。
  >
  > 但是其在并发场景下会浪费大量的资源，比如C/S架构中，服务器要响应多个客户端的请求，为了避免请求阻塞，服务器只能创建大量工作线程去响应请求，浪费系统资源（创建的少了，又会导致大量阻塞）

* 异步IPC

  单向、双向通信都可以。

  单向通信很好理解，直接扔给接收方一个信息然后跑路就可以了。如果接收方正在处理其他任务怎么办？异步发送方可以通过维护一个**内核缓冲区暂存消息**，避免等待。

  > 缓冲区有常见的三种设计：零容量，有限容量，无限容量。缓冲区空间耗尽之后只能选择阻塞式等待。

  双向通信在异步IPC中通过**轮询内存状态或注册回调函数**(如果内核支持)，来获取返回结果。

#### ③超时机制

上面的同步实现和异步实现有个问题，就是如果被调用者迟迟不返回调用结果，同步IPC直接就阻塞死了，异步可能会花费过长的时间等待请求的处理结果或者是在内核缓冲区等待请求的响应。

> 如果上面那个“迟迟”是恶意的，就称为拒绝服务(denial-of-service)攻击。

超时(Time-out)机制就是一个很好的解决方案——超过Time-out限定的时间就返回错误信息。

但是超时机制也存在一个问题：大部分进程很难确定一个合理的超时。Time-out过短可能会导致调用者频繁地重试一个IPC调用；Time-out过长可能会导致调用者无法及时察觉被调用者的异常。

两个特殊的超时选项（极限状态）：

* 永不返回or一直等待（阻塞）
* 立即返回or不等待（非阻塞）

所以大部分发送者进程只能根据需求进行选择：更加注重安全性的更倾向于不等待；更加注重功能性的更倾向于一直等待。

###（3）通信连接管理

#### ①直接通信与间接通信

直接通信：进程的一方需要显式的标识另一方。一个连接和一对进程之间的关系是一一对应的。

间接通信：需要一个中间的**信箱**。通信的双方不知道对方是哪个特定的进程，它们只知道双方共享这个信箱。

####*②权限检查

微内核——Capability机制：将所有的通信连接抽象为内核对象，进程对内核对象的访问权限（也即进程内否建立连接）有Capability来刻画。成功的访问需要发起进程有Capability而且其指向目标进程。

宏内核（以System V为例，其三者享有同样的权限管理方法）——基于文件权限检查机制：每个文件都会存储和用户（所有者用户/用户组用户/其他用户）以及权限（可读/可写/可执行）的组合相关的**访问模式**(mode)，之后如果有进程需要访问这个文件，就根据进程的用户分类，在访问模式中查找对应的权限，看与用户的请求是否匹配。

宏内核的权限管理和上面文件的权限检查机制十分相似：首先将通信的连接抽象为一个个对象，然后内核为每个通信对象设置一个类似文件中的“访问模式”，就可以根据其检查一个进程的操作是否合法。

```c
//访问模式被抽象为IPC_PERM结构体
struct ipc_perm{
    key_t key; //IPC对象的标识符
    uid_t uid; //所有者(owner)的uid和gid
    gid_t gid;
    uid_t cuid; //创建者(creator)的uid和gid
    gid_t cgid;
    mode_t mode;  //访问模式
}
```

#### *③权限的分发

如何分发权限？——通过用户态的命名服务(naming service)来实现。

服务端进程可以将自己提供的服务告诉命名服务进程。之后客户端可以去命名服务上查询当前的服务，并选择自己需要连接的服务并尝试获取权限。至于权限分不分发，由命名服务和对应的服务端进程根据特定的策略来判断。

> 除了命名服务，继承也是一种常见的分发连接权限的机制。这种方式一般产生于fork的父子进程之间。权限的获取本质上更加“私密”，保密性、安全性更好。

## 3.宏内核下的主流实现机制

###（1）管道

####①概述

管道是**单向的IPC**，内核中通常有一定的缓冲区来缓冲消息（但管道本身不需要存储设备）。通信的数据（消息抽象）是**字节流**，需要应用自己去对数据进行解析。

#### ②具体实现

管道在UNIX系列的系统中被当做一个文件：内核会为用户态提供代表管道的**两个独立的文件描述符**，用户态进程可以通过文件系统相关的系统调用来使用。

值得注意的是，如果还没有数据写入，拿着输出端的进程就开始尝试读数据，可能会发生：

* 寄：如果系统发现当前没有任何进程有这个管道的写端口，就会直接返回EOF
* 等着：否则会阻塞在这个系统调用上，直到数据到来。

#### ③优点与问题

优点: 设计和实现简单，针对简单通信场景十分有效

问题: 

* **缺少消息的类型，接收者需要对消息内容进行解析**
* 缓冲区大小预先分配且固定
* 只能支持单向通信
* 只能支持最多两个进程间通信

#### *④管道连接的建立

1. 匿名管道

   通过pipe的系统调用创建，调用的进程会同时获得读写的端口。之后其可以通过fork的方式完成IPC权限的分发，父子进程会同时拥有管道的两端，父/子主动根据需求主动关闭多余的端口即可。

   适用于关联性较强的进程，对于两个关系较远的进程就不太适用。

2. 命名管道

   由mkfifo创建。在创建的时候会指定一个全局的文件名，由这个文件名来指代一个具体的管道。之后只要两个进程通过一个相同的管道名进行创建（并且都拥有对其的访问权限），就可以实现在任意两个进程间建立管道的通信连接。

###（2）消息队列

#### ①数据抽象

以**消息**为数据抽象，消息的格式为：类型+数据。

类型是一个整型变量，在存储端看来和数据段没有任何区别，其具体的意义用户来决定。

拥有类型使得消息队列机制与管道不同——**可以按照类型查询**： Recv(A, type, message)

* 类型为0时返回第一个消息 (FIFO)
* 类型有值时按照类型查询消息：如type为正数，则返回第一个类型为type的消息

#### ②消息队列的结构

一个以链表形式组织的队列。

其包含IP_PERM（权限结构体）以及消息头部指针。

#### ③基本操作

1. msgget

   允许进程获取已有消息队列的连接，或者创建一个新的消息队列。

   由于消息队列本质上是采取**信箱**这种间接通信方式，所以说只要有对应的权限，消息队列机制允许任意数量的进程连接到同一通信连接上（即同一队列上）。

2. msgctl

   控制和管理一个消息队列，如消息队列的权限信息或删除消息队列。

3. msgsnd&msgrcv

   可以同时多进程随意发送与接收消息。

   大部分情况下这两个过程是非阻塞的，除非遇到Exception（读的时候发现没东西或写的时候发现没空间），此时可以让用户选择是否等待（NOWAIT选项）：选了NOWAIT，遇到这种意外就直接返回相关的错误信息，不阻塞用户进程。

###（3）消息队列 **VS.** 管道

**缓存区设计:** 

消息队列: 链表的组织方式，**动态**分配资源，可以设置很大的上限

管道: **固定**的缓冲区间，分配过大资源容易造成浪费

**数据抽象:** 

消息队列: 带类型的数据

管道: 数据 (字节流) 

**连接上的通信进程:** 

消息队列: 可以有多个发送者和接收者，可以单向、双向通信。

管道: 两个端口，最多对应两个进程，只能单向通信。

**消息的管理:** 

消息队列: FIFO + 基于类型的查询

管道: FIFO

