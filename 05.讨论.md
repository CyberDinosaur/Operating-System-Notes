关于内核栈：不是说有专门的“内核态线程”吗？用户态线程的相关特权功能究竟是由进程内部的内核内存（由用户创建还是OS创建）来实现，还是由内核态线程（地址空间与进程有没有联系）来实现？

为了搞明白这个问题，我们首先思考一下，进程之于内核是什么关系。

内核在物理内存当中有专门的区域，借助内核页表基址寄存器所访问。其对于用户态是不可见的。只有用户态应用触发某些操作，使得CPU状态由用户态进入内核态，才能对其进行访问、也即进行某些具有特权的内核操作。

而一个进程，从存储状态上来讲，和内核以及其它的一切没有本质区别，都只是物理内存上的一个区域，其表征着我们对于一个应用的资源管理单位。一般情况下，应用就在进程对应的物理内存上愉快地进行各种用户态操作，直到其因为需要系统调用或者其它原因，需要OS进行宏观调控，此时CPU会**进入内核态**，完成对应的操作。一句“进入内核态”，看似简单，但其究竟是如何实现的呢？

首先CPU收到进入内核态的信号之后，就可以借助内核页表寄存器对内核物理内存区间上的代码进行访问，进行某些特权操作。但是进行特权操作的过程中也需要临时保存某些数据，这些数据保存在哪里呢？随便找一个物理内存区间上扔着吗？拜托诶，这可是内核相关的数据！不怕被黑客抄家吗？而且存在物理内存上，乱七八糟，一个进程这样干还好，一堆进程这样干不直接就寄了？！所以我们干脆直接在进程的虚拟内存空间内部划分出一个特权级的区域，用来存储一些进入内核态时各个进程所独有的状态量，这样既能保证进程间的数据隔离性，又没有破坏用户态与内核态之间的划分。

但是进程只能算是内存资源的划分单元，OS真正进行调度的单元是线程，所以各种资源都要进行相应的划分。

