# 一.概述

为什么需要调度？——计算机系统的物理资源是有限的，而其所处理的任务数是没有上限的。

所以问题就在于我们如何在有限资源的前提下进行博弈，使调度策略能够实现利益的最大化。

## 1.调度的定义

 **协调请求对于资源的使用**。

<img src="图片\调度01.jpg" style="zoom:80%;" />

根据调度物理资源的类型，我们可以将计算机系统中的调度分为：

* **任务调度**：负责调度可执行任务对CPU的使用。（本章讨论的重点）

  * **任务调度的对象：**

    任务调度中，因为进程是进行资源隔离的单位，而不是执行的单位，所以调度器调度的对象是线程而不是进程，在Linux操作系统中我们通常用任务(task)来描述线程。

  * **任务调度的过程：**

    任务调度中的调度器一般会通过维护运行队列的方式来管理任务，运行队列里都是可以且需要运行的任务，由调度器挑选放入某个CPU中运行一段时间，之后如果还需要运行就回到调度器，否则被回收入==？==。关键点就在于调度器的逻辑该如何设计！这也是我们接下来这一章的中心内容，也即基于不同的硬件资源（CPU数目）、应用的行为特征、用户的需求，设计出一个能实现利益最大化的调度器。

    <img src="图片\调度09.jpg" style="zoom:80%;" />

    > PS：除了调度器运行逻辑的设计，任务调度的流程中还有一个点就是运行中的任务在什么情况下会返回调度器中：
    >
    > * 该任务执行完调度器给它分配的时间片。
    > * 该任务发起了I/O请求，在I/O结果返回之前，其不会继续执行。
    > * 该任务主动停止执行或进入睡眠
    > * 该任务被系统中断打断，系统优先处理中断而暂缓该任务的执行。

* **内存调度**：负责管理哪些进程==？==可以被任务调度器来管理、运行，比如换页机制。（第4章讨论）

* **I/O调度**：负责应该以何种顺序向存储设备发起I/O请求进行调度。（第9章讨论）

  > 上面的调度主要存在于内核态，但是由于内核难以预测应用的相关行为特征，所以目前越来越多的用户态程序也开始实现自己的调度器。

## 2.任务调度器的设计

我们的目的是通过调度决策实现“利益”最大化，我们主要讨论三个问题：（1）调度器究竟要做什么？（2）有哪些量化的调度指标制约我们调度器的形态？（3）**如何在实际场景中，基于调度指标作出最好的调度决策？**

### （1）调度决策的内容

* **Which**：从运行队列中选择下一个运行的任务。
* **Where**：决定该任务的CPU核心。
* **How many**：决定该任务被允许运行的时间，也即时间片的划分长度。

###（2）调度的量化指标

由于应用场景十分多变，用户的需求十分多态，所以不同场景下的调度指标可能会有所不同。

#### ①共有的

* 资源利用率：保证系统资源能够被尽可能的充分利用。
* 公平性：每个任务都有被执行的可能。
* 调度的开销：调度器本身所需要的性能开销应当尽可能的小，其本身不会占据过多的资源。

#### ②其它

* 批处理任务

  如重复性的科学计算或者机器学习训练等，不需要与用户进行交互，只需要尽快的大批量的任务执行完毕。

  * 吞吐量：单位时间处理任务的数量。
  * 周转时间：任务从发起直至执行结束所需要的时间应当尽可能的短。

* 交互式任务
  * 响应时间：任务从发起直至第一次向用户返回输出以响应用户的时间。
* 实时任务
  * 实时性
* 移动设备
  * 能耗：除了要尽可能的高性能，还要充分考虑到其与续航时间的博弈。

<img src="图片\调度02.jpg" style="zoom:80%;" />

### （3）基于调度指标做出调度决策

这就是我们接下来这一章关注的重点。它并不像其看起来的那样简单，原因在于：

* **调度指标难以确定**：工作场景动态变化会导致塑造调度器的调度指标会发生变化，使得静态调度器难以适应各种场景
* **决策信息不足**：调度指标只是我们决策的方向，真正作出决策还要基于当下需要处理的任务结构、应用未来的行为特征、系统本身的物理框架（CPU数量、组织架构）...这些信息很多都是非确定性的，这就导致我们不可能根据确定性条件找到最优解，只能根据历史信息作出概率性的预测。
* **线程/任务间的复杂交互**：处理不好就会产生各种问题
* **各种冲突点的博弈**：
  * 调度开销与调度效果
  * 优先级与公平性
  * 性能与能耗

> 所以本质上来讲，调度器的设计就类似于你的人生，你不知道你从哪里来，你不知道你是谁，你也不知道你要到哪里去。所以你只能选择~~躺平~~硬着头皮在现实结构的基础上、根据不同场景动态的决定衡量你人生价值的量化指标，并且在现有信息的基础上找到一种尽可能优秀的策略、完成具有复杂交互关系的各种任务(task)，以期能够做到量化指标定义之下的“最优化”。

# 二.调度的机制

## 1.总览

<img src="图片\调度03.jpg" style="zoom:80%;" />

任务调度大致可分为长期、中期、短期三种调度，而且要注意的是，其虽然主要是考虑对CPU资源的分配，但是也涉及到对于内存和I/O资源的平衡考虑。

**长期调度**的触发间隔时间较长，它粗粒度的决定是否应当将一个新的进程纳入调度管理，负责增加系统中可被调度的进程的数量；**中期调度**的触发相对频繁，其辅助换页机制，负责限制系统中可被调度的进程的数量；**短期调度**的触发最为频繁，其负责细粒度的调度进程的执行，做出相应的调度决策。

## 2.内容

**进程的调度机制主要是负责进程在其生命周期的各种状态间进行转换。**

###（1）长期调度

> 当一个程序尝试运行时，OS是否应当立即为其创建一个进程，并将对应的进程设置为就绪状态？
>
> ——Yes？会导致调度决策（短期调度）需要考虑的进程数量剧增，调度开销变得十分巨大。

根据系统资源的利用率从全局出发，限制真正被短期调度所管理的进程数量。

除了控制总体上控制进程的数量，更加细分的看，长期调度还可以根据当前系统的CPU、I/O利用率情况，选取合适的计算密集型或者I/O密集型进程，交由短期调度管理。如此可以有效的控制系统的资源利用均衡，不会导致激烈的资源竞争或某项资源利用率过低的情况。

PS：由于交互式任务和实时任务对于时延的要求一般比较高，所以其一般会直接创建进程，而不被长期调度管理。

<img src="图片\调度16.jpg" style="zoom:80%;" />

### （2）短期调度

主要负责进程在就绪状态、运行状态、阻塞状态间的转换，主要平衡CPU的资源利用（也就是们在上面所说的“任务调度器”，其决策的逻辑是本章的主要内容）

<img src="图片\调度17.jpg" style="zoom:80%;" />

###（3）中期调度

长期调度和短期调度主要是从CPU与I/O资源的平衡上考虑，但是内存资源没有被考虑。虽然长期调度可以在总体上控制进程的数量，但是在运行中依旧有可能出现系统内存资源超负荷的现象。

中期调度是换页机制的一部分，其会把一些影响性能的进程（频繁触发缺页异常、长时间未响应的进程）挂起。挂起状态标志无法被调度执行，而且换页机制会倾向于优先选择被挂起的进程所使用的内存页被替换入磁盘。

<img src="图片\调度18.jpg" style="zoom:80%;" />

PS：处于挂起阻塞状态的进程虽然无法被调度，但是仍然可以响应某些事件，被设置为挂起就绪状态。

## 3.Linux内核调度

两种调度器：

* 公平调度(Complete Fair Scheduler, CFS)

* 实时调度(Real-Time Scheduler, RT)

# 三.单核调度策略

## 1.经典调度策略

### （1）先到先得(First Come First Served)

直接将进程被调度的优先级和其**到达时间**相挂钩。

<img src="图片\调度04.jpg" style="zoom:80%;" />

问题在于用户到来的时间线性关系和“优先级”不一定呈正相关，大概率会造成总体博弈成本的增加。

* 对短任务不友好：在长任务与短任务混合的场景下，有可能会造成短任务的周转时间远远长于运行时间，降低用户体验。
* 对I/O密集型任务不友好：由于FCFS的非抢占式特性，对于计算占用时间较少而I/O较为密集的任务，（配合计算占用时间较多的任务），很有可能会出现I/O资源占用率低的现象。

### （2）最短任务优先(Shortest Job First)

将任务被调度的优先级与**任务的执行时间**挂钩。

<img src="图片\调度05.jpg" style="zoom:80%;" />

* 必须预知任务的执行时间：取决于当前系统的状态和其它影响程序性能的因素，难以准确预知。
* 其表现严重取决于任务的到达时间点，极端的甚至有可能会出现完全相反的LJF的情况，而这依旧源于其非抢占性的弊端。

### （3）抢占式调度 (Preemptive Scheduling)

* 非抢占式调度：一定是前一个任务执行完毕再执行下一个
* 抢占式调度：每次任务执行一定时间后会被切换到下一任务，而非执行至终止。通过定时触发的时钟中断实现。

#### ①最短完成时间任务优先(Shortest Time-to-Completion First)

将任务调度的优先级与其预计的完成时间相挂钩。实际上就是SJF的抢占式版本，在任务到达或者需要选取调度任务的时候，选取距离完成时间最近的任务。

<img src="图片\调度06.jpg" style="zoom:80%;" />

* 依旧需要预知任务的运行时间。
* 长任务饥饿

####②时间片轮转(Round Robin)

之前讨论的单核调度策略主要是针对批处理任务的，它们主要关注的调度指标是调度时间，其特点是只有在任务到达或结束时才会进行调度。

但是对于交互式任务，用户更在意的可能是响应时间。为了定时响应用户，我们可以采用时间片轮转的策略。

<img src="图片\调度07.jpg" style="zoom:80%;" />

RR无须预知任务的运行时间，也不会出现长任务饥饿的现象，看似达到了“公平”以及响应时间可控的结果。

但是伴随这两个优点的是两个博弈的困境：

* 公平与总体性能：RR虽然在一定程度上保证的任务之间的公平性，获得了良好的响应时间，但是其在某些特定场景下（如每个任务的运行时间相似）可能会导致总体的平均周转时间变大。
* 响应时间与调度开销：这一博弈项直接控制切分时间片大小的选取，时间片过短，响应时间低，但是调度器本身计算资源消耗比较大；时间片过长，调度开销变小了，但是有可能会无法满足用户对于较低响应时间的需求。

时间片轮转最大的问题就在于**时间片切分格式过于死板**and**时间片的长度过于死板**。

前者会导致当程序数量较多的时候，会导致时间片切分过细，有一些程序可能会等待好多时间片后才能运行。

后者的问题关键在于时间片的长度难以确定——信息缺失。

## 2.优先级调度

从用户**需求**的角度来看，我们实际上是能够找到一些调度的“优先级”的，比如前台程序和后台程序、系统和用户...

安排任务的优先级有多种角度：

* 有明确**截止时间的实时任务**，优先级最高
* **交互式任务**分配较高优先级
* 批处理任务优先级较低

### （1）多级队列(Multi-Level Queue,MLQ)

MLQ是一种相对**静态**的策略，适用于任务信息（如任务的导致运行时间，资源使用情况）可以在执行前获知的场景。

每个任务都会被预先设置一个优先级，每个优先级对应不同的优先级队列。高优先级的任务优先执行，同优先级内部没有统一的标准，可以为不同的队列设置不同的调度策略，如FCFS,RR。

<img src="图片\调度10.jpg" style="zoom:80%;" />

问题与改进：

* 在I/O密集与计算密集任务混合的场景，应当将I/O密集的任务优先级提高。

* **低优先级任务饥饿**：

  为了保证公平性，避免MLQ带来的饥饿，需要设置额外的机制监控任务等待时间，如果等待时间超过一定的阈值就提升其优先级。

* **优先级反转**：高、低优先级的任务都需要独占共享资源，低优先级任务占用资源就会导致高优先级任务被阻塞。

  可以通过**优先级继承**的方式来解决，也即高优先级的任务在遇到共享资源被低优先级任务锁定时，可以将其优先级“假借”给低优先级任务，并让其执行并放锁==？==。之后高优先级的任务可以通过抢占的方式来执行。

### （2）多级反馈队列(Multi-Level Feedback Queue,MLFQ)

在**无法预知任务信息**且**任务类型动态变化**（任务行为模式会在计算密集和I/O密集型之间来回切换）的场景下适用，可能同时达到较低的周转时间与响应时间。

基于MLQ，同样具有多级队列，不过队列内部一般采用RR策略。

####①短任务具有更高的优先级

好处：

* 借用SJF的思想，优先调度短任务可以拥有更好的平均周转时间。
* 一般I/O任务的CPU时间较短，所以给与短任务较高的优先级就相当于提高I/O密集任务的优先级。
* 交互任务一般也是短任务，故而此操作也有助于降低交互任务的响应时间。

此外，MLFQ不追求准确的预测出任务的运行时间，而是首先**假设其是短任务并将其设置为最高优先级**，之后监控各个任务在CPU中的运行时间，如果**超过预先设定的阈值**——最大运行时间（指任务多次运行的总时间，而非单一时间片），就预测其对于此优先级来说是长任务，**将其对应的优先级-1**。

#### ②低优先级任务采用更长的时间片

减少任务来回切换的开销。

#### ③定时地将所有任务的优先级提升至最高

为了解决MLQ中可能会产生的低优先级任务饥饿问题。

> 之所以不采用MLQ中的监控各个任务等待时间，并设置阈值，是考虑到：
>
> 1. 可能存在计算密集任务向交互式任务转换的情况，这种处理方案是为了防止上述情况发生所造成的响应时间增加。
> 2. 前者开销太大，不如“死板”一点。

## 3.公平共享调度

前面的调度策略都是基于任务和物理资源的，但是由于一些“场外因素”，各个用户对CPU的占用时间的比例应当是固定的。

### （1）优先级VS份额

在公平共享调度中，对于“任务重要性”主要使用资源占有的份额来量化。

优先级：侧重点在于“谁先谁后”。

份额：侧重点在于“谁多谁少”。

> 为了方便进行管理，我们可以将任务分成各个任务组，以任务组为单位分配份额，之后再进行组内分配。

### （2）彩票调度

####①算法描述

问题的关键在于如何高效地达到公平共享的目标？

CPU资源占用比例 $\Rightarrow$ 任务组的份额比例 $\Rightarrow$ 数值区间长度比例。

之后在每次调度时，我们随机产生一个随机数 $R$ ，并以此决定被调度的任务。

```c
R = random(0, T)
sum = 0
foreach(task in task_list) {
	sum += task->ticket  //总和超过随机数，表征随机数落到任务的数值区间。
	if (R < sum) {
	schedule()
	break
	} 
}
```

#### ②优化措施

##### A.彩票转让

适用于各种同步场景，比如在通信过程中，客户端要等到服务端返回后才能继续执行，以及类似MLQ中共享资源导致的优先级反转问题。

客户端将自己的ticket交给服务端，确保服务端可以尽可能使用更多资源，迅速处理。

<img src="图片\调度12.jpg" style="zoom:80%;" />

##### B.彩票货币

组内分配的措施。各个任务组内可以发行一定规模的货币，对其下的子任务分配CPU资源时的直接分配对象是货币。

这种间接分配任务组份额的方式可以适应任务组动态修改自己持有份额的场景，避免影响从属于它们的任务。

##### C.彩票通胀

给任务一定的自由度，允许其根据任务对CPU资源的需求决定自己的份额，可以动态的适应任务的需求变化，不过这种措施需要任务之间的高度信任，否则可能会产生任务过分抢占资源的“恶意通胀现象”。

####③彩票调度随机性的利弊

* 优点：简单

* 缺点：

  主要源于调度决策的随机性，只有当调度次数比较大的时候，任务对CPU资源的占有比例才会倾向于份额的比例；当调度次数比较小的时候，其比例会与预期有较大的误差。

### （2）步幅调度

将ticket的比例以一种确定性关系映射到CPU占用时间上。

份额越大，步幅越小，这样任务被调度次数会越多。
$$
stride =\frac {MaxStride}{ticket}
$$
PS: $MaxStride$ 是所有tickets的最小公倍数。

```c
// 选择并移除运行队列中虚拟时间最小的任务
task = remove_queue_min(q);
// 调度该任务并让其执行一个时间片
schedule(task);
// 使用该任务的步幅计算调度后的虚拟时间
task->pass += task->stride;
insert_queue(q, current);
```

Pass表征任务的累计虚拟时间==？==

## *4.实时调度

除优先级和份额之外，我们还应当考虑任务的实时性对于调度的影响。

每个任务都有截止时间(Deadline)：

* 软实时(Soft Real Time)：比如视频播放，每一帧的渲染，超过截止时间会导致画质差
* 硬实时(Hard Real Time)：比如自动驾驶汽车的刹车任务。

而且我们有一个头大的问题：普通系统很难做到确定性时延。最小时延和最大时延的差别很大，而且最大时延也不稳定。

### （1）可调度充要条件

$$
U=\sum_{i=1}^{m}\frac {C_i}{T_i}\le 1 
$$

也即CPU的利用率小于等于1。

通过计算 $U$ ，调度器可以快速判断是否存在一种调度序列，能够使得一组任务全部在截止时间之前完成。

### （2）速率单调策略(Rate-Monotonic, RM)

在所有基于静态优先级的实时调度策略中，RM策略是最优的。

任务周期越短，表示任务速率越大，优先级越高，应该先被调度。

<img src="图片\调度19.jpg" style="zoom:80%;" />

> RM策略的最坏情况估计：
>
> 当RM策略需要调度N个任务的时候，其最坏情况下的CPU利用率为 $N*(2^{1/N}-1)$ 

###（3）最早截止时间优先(Earliest Deadline First, EDF)

 $U \le 1$ 的充要条件是EDF可以在任务的截止时间前完成任务。

$U \gt 1$ 时，EDF策略反而会因为一个任务错过截止时间而导致大量后续任务级联地错过截止时间，一般称为多米诺效应。

> 不出错就是最好的，出错就是代价最高的。

























